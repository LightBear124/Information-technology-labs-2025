# **Введение** #

Данная лабораторная работа направлена на настройки и интеграции между GitLab и Nexus, реализации автоматического пайплайна CI/CD для Python-приложения, включающего запуск тестов, сборку Docker-образа и его публикацию в репозиторий Nexus.

Работу выполнили студенты ИС-23:

- Эльзессер А. Ф.

- Остафинский В. А.

## Подготовка окружения (GitLab + Nexus) ##
Для начала необходимо поднять сервисы **GitLab** и **Nexus** с помощью **Docker Compose**.
Создаём папку **lab4** командой
```
mkdir ~/lab4
```
и переходим в неё командой cd. Далее создаем файл docker-compose командой
```
docker-compose.yaml
```
Заполняем его содержимым:

<p align="center">
  <img src="media/image001.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

<p align="center">
  <img src="media/image002.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

Далее загружаем и запускаем контейнеры командой
```
docker compose up -d
```
После запуска контейнеров проверим их статус командой
```
docker ps -a
```

<p align="center">
  <img src="media/image003.png" alt="Скриншот с заданными размерами" width="1000" height="300">
</p>

В файл **/etc/hosts** внесем записи **gitlab.local** и **nexus.local**. Это нужно для того, чтобы операционная система знала, как преобразовать эти доменные имена в IP-адреса, потому что это не реальные домены в интернете, а локальные имена для наших контейнеров.

<p align="center">
  <img src="media/image004.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

После запуска проверяем доступность сервисов:
- GitLab: http://gitlab.local:8888

<p align="center">
  <img src="media/image006.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

- Nexus: http://nexus.local:8082

<p align="center">
  <img src="media/image005.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

После запуска контейнера **GitLab** пароль генерируется автоматически и хранится внутри контейнера. Пароль администратора Nexus также хранится в файле внутри контейнера. Чтобы их получить нам нужно выполнить несколько команд. Для **Gitlab**:
```
docker exec gitlab grep 'Password: ' /etc/gitlab/initial_root_password
```
Для nexus:
```
docker exec nexus cat /nexus-data/admin.password
```

<p align="center">
  <img src="media/image008.png" alt="Скриншот с заданными размерами" width="1000" height="300">
</p>

Далее нам нужно зайти в **Gitlab** под именем **root** с помощью полученного пароля. По итогу видим начальную страницу:

<p align="center">
  <img src="media/image007.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

Для **Nexus** проделываем все то же самое, но под именем **admin**. Важно знать, что пароль, полученный из контейнера, будет стерт сразу после первого входа. По итогу так же видим главную страницу:

<p align="center">
  <img src="media/image009.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>


## Создание Docker-репозитория в Nexus ##
Для хранения собранных Docker-образов в **Nexus** необходимо создать специальный репозиторий типа Docker (hosted). Для этого переходим в раздел репозиториев. На открывшейся странице видим список существующих репозиториев:

<p align="center">
  <img src="media/image010.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

Нажимаем кнопку **Create repository** в верхней части страницы. Формат нашего репозитория - docker с типом hosted для хранения собственных образов. Далее заполняем форму:
- **Name:** docker-hosted (можно любое имя)
- **HTTP:** ставим галочку и указываем порт 5000 (Это порт, который будет слушать Docker Registry API)
- **Allow anonymous docker pull:** для CI/CD обычно разрешаем, чтобы не нужно было каждый раз логиниться.
- **Strict Content Type Validation:** гарантирует, что в Docker-репозиторий загружаются только Docker-образы. Предотвращает случайную загрузку файлов неправильного типа и повышает безопасность.
- **Deployment policy:** allow redeploy - разрешить переразвёртывание для перезаписи существующих артефактов


<p align="center">
  <img src="media/image011.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

<p align="center">
  <img src="media/image012.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

## Проверка работоспособности Docker Registry в Nexus ##
Для проверки доступности и функциональности Docker Registry был выполнен HTTP-запрос к API реестра с использованием утилиты **curl**:
```
curl -I http://nexus.local:5000/v2/
```
Опция **-I** была использована для получения только заголовков HTTP-ответа, что позволяет оценить работоспособность сервиса без загрузки полного содержимого ответа.

<p align="center">
  <img src="media/image013.png" alt="Скриншот с заданными размерами" width="1000" height="300">
</p>

**HTTP/1.1 401 Unauthorized** — код состояния HTTP 401 свидетельствует о том, что запрос требует аутентификации пользователя. Это ожидаемое поведение для защищенного Docker Registry, что подтверждает его работоспособность.

## Настройка Docker для работы с репозиторием ##
Так как используется HTTP, нужно добавить **Nexus** в список insecure-регистров. Для этого редактируем конфигурацию Docker:
```
sudo nano /etc/docker/daemon.json
```
добавляем содержимое:
```
{
  "insecure-registries": ["nexus.local:5000"]
}
```
и перезапускаем docker:
```
sudo systemctl restart docker
```
## Создание и настройка GitLab Runner для выполнения пайплайнов ##
GitLab Runner — это отдельная программа, которая выполняет задания (jobs) из **.gitlab-ci.yml**. Без раннера пайплайны не будут запускаться. GitLab только управляет заданиями, а Runner их выполняет.

### Создание Runner в GitLab ###
Создадим раннер в веб-интерфейсе гитлаба через кнопку "Create instance runner". Instance runner — это раннер, доступный для всех проектов на всём экземпляре GitLab. В отличие от специфичных раннеров, инстанс раннеры могут использоваться любыми проектами. Заполняем форму:
- **Description:** вводим понятное имя, например lab4-docker-runner
- **Tags:** оставляем пустым
- **Run untagged jobs:** включаем, раннер будет пытаться выполнять все задания, даже не помеченные тегами
- **Maximum job timeout:** оставляем 60 минут
- **Token expiry:** оставляем "Never expires"

<p align="center">
  <img src="media/image014.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

<p align="center">
  <img src="media/image015.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

### Устанавливаем GitLab Runner на машину ### 
Скачиваем бинарник командой
```
curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash
```
Далее устанавливаем раннер:
```
sudo apt-get install gitlab-runner
```
Убедимся в успешности установки и проверим версию командой
```
gitlab-runner --version
```

<p align="center">
  <img src="media/image016.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

Далее нам нужно зарегестрирвоать раннер. Делаем это с помощью команды
```
sudo gitlab-runner register
```
Появится диалог, в котором мы отвечаем:
- **Enter the GitLab instance URL:** http://gitlab.local:8888/
- **Enter the registration token:** (копируем токен из настроек проекта)
- **Enter a description for the runner:** lab4-runner
- **Enter tags for the runner (comma separated):** (оставляем пустым)
- **Enter optional maintenance note for the runner:** (оставляем пустым)
- **Enter an executor:** docker
- **Enter default Docker image:** docker:24.0

Далее проверяем успешность регистрации с помощью просмотра списка раннеров. Выполняем команду
```
sudo gitlab-runner list
```

<p align="center">
  <img src="media/image022.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

Конфигурация раннера:

<p align="center">
  <img src="media/image023.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

Runner использует образ **docker:24.0** и монтирует **Docker socket**, что позволяет:

- Запускать Docker команды внутри CI/CD пайплайна

- Собирать Docker образы

- Запускать тесты в изолированных контейнерах

- Работать с Docker Registry

## Создание файлов Python-приложения и настройка CI/CD Variables в GitLab ##
### Создание файлов Python-приложения ###
Создадим структуру проекта. Для этого сделаем и перейдем в новую папку **python-app** командами
```
mkdir python-app
cd python-app
```
Добавим следующие файлы:
- text_tool.py - основное приложение, содержащее две функции для подсчета количества слов и нахождения самого длинного слова в тексте.
- test_text_tool.py - модульные тесты
- requirements.txt - зависимости Python
- Dockerfile - конфигурация Docker-образа
- .gitlab-ci.yml - конфигурация CI/CD пайплайна

<p align="center">
  <img src="media/image018.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

В докер-файле укажем следующие содержимое:
```
FROM python:3.10
WORKDIR /app
COPY text_tool.py /app/
CMD ["python"]
```
В файле .gitlab-ci.yml распишем наш пайплайн. Основные его части:
- **stages:** определяет этапы пайплайна (сначала тесты, потом сборка)
- **variables:** глобальные переменные для всего пайплайна
- **test job:** запускает тесты в контейнере Python 3.10
- **build_and_push job:**
  - Использует Docker-in-Docker для сборки образов
  - Логинится в Nexus
  - Собирает Docker-образ с тегом = короткий хеш коммита
  - Пушит образ в Nexus
- **only: main:** запускается только для ветки main

<p align="center">
  <img src="media/image019.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

### Создание CI/CD Variables в GitLab ###
Переменные хранят чувствительную информацию (логины, пароли, токены), которую нельзя хранить в коде. Они передаются в окружение **jobs**.

Создаём переменную NEXUS_USER:
- **Key:** NEXUS_USER
- **Value:** admin

Создаём переменную NEXUS_PASSWORD:
- **Key:** NEXUS_PASSWORD
- **Value:** пароль из nexus/local:8082

Параметр **Protect variable** отвечает за доступность только для защищённых веток (main/master)
, а **Mask variable**  скрывает значение в логах

<p align="center">
  <img src="media/image020.png" alt="Скриншот с заданными размерами" width="1000" height="400">
</p>

### Работа с репозиторием ###
После создания переменных нужно запушить данные в **GitLab**, чтобы запустился **CI/CD** пайплайн. Создаем публичный репозиторий на гитлабе с помощью кнопки New Project. Далее локально переходим в директорию проекта командой
```
cd ~/python-app
```
Инициализируем локальный Git репозиторий с помощью
```
git init
```
Связываем удаленный и локальный репозитории
```
git remote add origin http://gitlab.local:8888/root/python-lab-app.git
```
Добавляем все файлы в staging area:
```
git add .
```
Делаем первый коммит
```
git commit -m "Add CI/CD pipeline"
```
Пушим в ветку master
```
git push -u origin master
```

## Запуск пайплайна ##
Мы не смогли закончить лабораторную работу по причине аппаратных ограничений, а именно недостатка оперативной памяти. На самом последнем этапе **Gitlab** отказывается прогружать наши пайплайны, а соответственно и выполнять **jobs**.

В идеале после коммита и пуша в ветку master в **GitLab** запустится пайплайн. Можно отслеживать его выполнение в разделе **Pipelines**. В идеале ожидаемый результат:
- Job test завершается успешно
- Job build_and_push собирает образ и пушит его в Nexus

Далее в **Nexus** можно было бы проверить наличие образа. Переходим в репозиторий docker-hosted и ищем тег **python-lab**. 

Из-за проблем с памятью у нас успевает запустился в работу лишь первый этап **test**, после которого браузер намертво зависает до тех пор, пока не произойдет перезагрузка ВМ.

<p align="center">
  <img src="media/image024.png" alt="Скриншот с заданными размерами" width="1000" height="250">
</p>

# Заключение #
В ходе лабораторной работы был настроен автоматизированный цикл CI/CD для Python-приложения. С помощью Docker Compose развернуты GitLab и Nexus, после чего они были интегрированы между собой. Созданное Python-приложение с тестами было помещено в GitLab-репозиторий, где настроен пайплайн: при пуше в основную ветку автоматически запускаются тесты, а при их успехе — собирается Docker-образ и отправляется в репозиторий Nexus. Мы не смомгли закончить лабораторную раюоту по причине аппаратных ограничений. В теории весь процесс работает автоматически, демонстрируя принципы непрерывной интеграции и доставки в современной разработке.